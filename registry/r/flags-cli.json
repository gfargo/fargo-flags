{
  "name": "flags-cli",
  "type": "registry:lib",
  "dependencies": [
    "react@^19.1.0",
    "lucide-react@^0.400.0",
    "class-variance-authority@^0.7.1",
    "clsx@^2.1.1",
    "tailwind-merge@^2.5.4",
    "tsx@^4.19.2",
    "prompts@^2.4.2",
    "fast-glob@^3.3.2",
    "prettier@^3.4.2"
  ],
  "registryDependencies": [
    "https://flags.griffen.codes/r/flags-core"
  ],
  "files": [
    {
      "type": "registry:lib",
      "path": "scripts/check-flags-registry.ts",
      "content": "import fs from \"node:fs\";\nimport path from \"node:path\";\nimport { pathToFileURL } from \"node:url\";\nimport fg from \"fast-glob\";\nimport { createPathResolver } from \"./path-resolver\";\n\nconst ROOT = process.cwd();\nconst pathResolver = createPathResolver(ROOT);\n\n// Use alias-aware path resolution\nconst DEFS_DIR = pathResolver.resolveFlagDefsPath();\nconst REG_FILE = pathResolver.resolveRegistryConfigPath();\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function importTs(p: string): Promise<any> {\n  const url = pathToFileURL(p).href;\n  return await import(url);\n}\n\nasync function main() {\n  // Convert absolute path to relative glob pattern for fast-glob\n  const relativeDefsDir = path.relative(ROOT, DEFS_DIR);\n  const defGlobPattern = path.join(relativeDefsDir, \"**/*.flag.ts\").replace(/\\\\/g, \"/\");\n  const defPaths = await fg(defGlobPattern, { cwd: ROOT });\n  const defs = await Promise.all(\n    defPaths.map(async (rel) => {\n      const abs = path.join(ROOT, rel);\n      const mod = await importTs(abs);\n      const key = mod.key ?? mod.default?.key;\n      if (!key) throw new Error(`Missing export 'key' in ${rel}`);\n      const isPublic = !!(mod.default?.client?.public);\n      return { rel, key: String(key), isPublic };\n    })\n  );\n\n  if (!fs.existsSync(REG_FILE)) throw new Error(\"registry.config.ts not found\");\n  const agg = await importTs(REG_FILE);\n  const regKeys: string[] = Object.keys(agg.registry ?? {});\n  const schemaKeys: string[] = Object.keys(agg.flagSchemas ?? {});\n  const publicKeys: string[] = Array.from(agg.clientFlagKeys ?? []);\n\n  const defKeySet = new Set(defs.map((d) => d.key));\n  const regKeySet = new Set(regKeys);\n  const schemaKeySet = new Set(schemaKeys);\n  const publicKeySet = new Set(publicKeys);\n\n  const missingInRegistry = [...defKeySet].filter((k) => !regKeySet.has(k));\n  const missingInDefs = [...regKeySet].filter((k) => !defKeySet.has(k));\n\n  const schemaNotInRegistry = [...schemaKeySet].filter((k) => !regKeySet.has(k));\n  const registryNotInSchemas = [...regKeySet].filter((k) => !schemaKeySet.has(k));\n\n  const filePublicNotListed = defs.filter((d) => d.isPublic && !publicKeySet.has(d.key)).map((d) => d.key);\n  const listedButNotPublic = publicKeys.filter((k) => {\n    const d = defs.find((x) => x.key === k);\n    return !d?.isPublic;\n  });\n\n  let ok = true;\n  function issue(title: string, items: string[]) {\n    if (!items.length) return;\n    ok = false;\n    console.error(`\\n${title}:`);\n    for (const i of items) console.error(`  - ${i}`);\n  }\n\n  issue(\"Defs present but missing in registry.config\", missingInRegistry);\n  issue(\"Registry keys missing corresponding defs\", missingInDefs);\n  issue(\"flagSchemas keys missing in registry\", schemaNotInRegistry);\n  issue(\"registry keys missing in flagSchemas\", registryNotInSchemas);\n  issue(\"Public flags in files but missing from clientFlagKeys\", filePublicNotListed);\n  issue(\"Keys in clientFlagKeys but flags not marked public in files\", listedButNotPublic);\n\n  if (ok) {\n    console.log(`✔ flags:check OK — ${regKeys.length} registered, ${defs.length} files, ${publicKeys.length} client-exposed`);\n    process.exit(0);\n  } else {\n    process.exit(1);\n  }\n}\n\nmain().catch((e) => {\n  console.error(e);\n  process.exit(1);\n});"
    },
    {
      "type": "registry:lib",
      "path": "scripts/create-flag.ts",
      "content": "import fs from \"node:fs\";\nimport path from \"node:path\";\nimport prompts from \"prompts\";\nimport { createPathResolver } from \"./path-resolver\";\n\nconst ROOT = process.cwd();\nconst pathResolver = createPathResolver(ROOT);\n\n// Use alias-aware path resolution\nconst DEFS_DIR = pathResolver.resolveFlagDefsPath();\nconst REG_FILE = pathResolver.resolveRegistryConfigPath();\n\nfunction snake(s: string) { return s.toLowerCase().replace(/[^a-z0-9]+/g, \"_\").replace(/^_|_$/g, \"\"); }\nfunction kebab(s: string) { return s.toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/^-|-$/g, \"\"); }\n\nasync function main() {\n  const answers = await prompts([\n    { type: \"text\", name: \"key\", message: \"Flag key (kebab-case)\", validate: v => /^[a-z0-9][a-z0-9-]*$/.test(v) ? true : \"kebab-case only\" },\n    { type: \"select\", name: \"kind\", message: \"Value type\", choices: [\n      { title: \"boolean\", value: \"boolean\" },\n      { title: \"string enum\", value: \"enum\" }\n    ]},\n    { type: prev => prev === \"enum\" ? \"list\" : null, name: \"options\", message: \"Enum options (comma-separated)\", separator: \",\" },\n    { type: \"toggle\", name: \"isPublic\", message: \"Expose to client?\", initial: true },\n    { type: prev => prev ? \"text\" : null, name: \"sanitizer\", message: \"Serializer (optional JS expr, e.g. v => !!v)\" },\n    { type: (prev, vals) => vals.kind === \"boolean\" ? \"toggle\" : \"text\", name: \"defaultValue\", message: \"Default value\", initial: true },\n    { type: \"text\", name: \"description\", message: \"Description (optional)\" }\n  ]);\n\n  const key = kebab(answers.key);\n  const base = snake(key);\n  const fileName = `${base}.flag.ts`;\n  const importId = `f_${base}`;\n  const defPath = path.join(DEFS_DIR, fileName);\n  fs.mkdirSync(DEFS_DIR, { recursive: true });\n\n  let schema = \"z.boolean()\";\n  let defVal = String(answers.defaultValue);\n  let optionsBlock = \"\";\n  if (answers.kind === \"enum\") {\n    const opts = (answers.options as string[]).map((s) => s.trim()).filter(Boolean);\n    schema = `z.enum([${opts.map((o) => `\"${o}\"`).join(\", \")}])`;\n    defVal = `\"${opts[0]}\"`;\n    optionsBlock = `\\n  options: [${opts.map((o) => `{ value: \"${o}\" }`).join(\", \")}],`;\n  }\n\n  const clientBlock = answers.isPublic\n    ? answers.sanitizer\n      ? `\\n  client: { public: true, serialize: ${answers.sanitizer} },`\n      : `\\n  client: { public: true },`\n    : `\\n  client: { public: false },`;\n\n  const contents = `import { z } from \"zod\";\nimport { defineFlag } from \"../kit\";\n\nexport const key = \"${key}\" as const;\nexport const schema = ${schema};\n\nexport default defineFlag({\n  key,\n  schema,\n  description: ${JSON.stringify(answers.description || \"\")},\n  defaultValue: ${defVal},${optionsBlock}${clientBlock}\n});\n`;\n\n  // Write flag file (skip if exists)\n  if (!fs.existsSync(defPath)) {\n    fs.writeFileSync(defPath, contents, \"utf8\");\n    console.log(\"✔ created\", path.relative(ROOT, defPath));\n  } else {\n    console.log(\"ℹ exists\", path.relative(ROOT, defPath), \"— not overwriting\");\n  }\n\n  // Update registry.config.ts\n  let cfg = fs.readFileSync(REG_FILE, \"utf8\");\n  const importLine = `import * as ${importId} from \"./defs/${base}.flag\";`;\n  if (!cfg.includes(importLine)) {\n    cfg = inject(cfg, /\\/\\/ @fargo-flags:imports\\n/, importLine + \"\\n\");\n  }\n\n  const schemaEntry = `  \"${key}\": ${importId}.schema,`;\n  if (!cfg.includes(schemaEntry)) {\n    cfg = inject(cfg, /\\/\\/ @fargo-flags:schemas\\n/, schemaEntry + \"\\n\");\n  }\n\n  const regEntry = `  \"${key}\": ${importId}.default,`;\n  if (!cfg.includes(regEntry)) {\n    cfg = inject(cfg, /\\/\\/ @fargo-flags:registry\\n/, regEntry + \"\\n\");\n  }\n\n  if (answers.isPublic) {\n    const pubEntry = `  \"${key}\",`;\n    if (!cfg.includes(pubEntry)) {\n      cfg = inject(cfg, /\\/\\/ @fargo-flags:public\\n/, pubEntry + \"\\n\");\n    }\n  }\n\n  fs.writeFileSync(REG_FILE, cfg, \"utf8\");\n  console.log(\"✔ updated\", path.relative(ROOT, REG_FILE));\n\n  // Auto-format with Prettier if available\n  await formatFiles([defPath, REG_FILE]);\n}\n\nfunction inject(src: string, anchor: RegExp, text: string) {\n  const m = src.match(anchor);\n  if (!m) throw new Error(\"Anchor not found in registry.config.ts\");\n  const insertAt = (m.index ?? 0) + m[0].length;\n  return src.slice(0, insertAt) + text + src.slice(insertAt);\n}\n\nasync function formatFiles(files: string[]) {\n  try {\n    const prettier = await import(\"prettier\");\n    for (const file of files) {\n      const src = fs.readFileSync(file, \"utf8\");\n      const cfg = await prettier.resolveConfig(file).catch(() => null);\n      const formatted = await prettier.format(src, { ...(cfg ?? {}), filepath: file });\n      fs.writeFileSync(file, formatted, \"utf8\");\n      console.log(\"✔ formatted\", path.relative(ROOT, file));\n    }\n  } catch {\n    console.warn(\"(prettier not installed — skipping format)\");\n  }\n}\n\nmain().catch((e) => { console.error(e); process.exit(1); });"
    },
    {
      "type": "registry:lib",
      "path": "scripts/path-resolver.ts",
      "content": "import fs from \"node:fs\";\nimport path from \"node:path\";\n\ninterface ProjectConfig {\n  aliases: Record<string, string>;\n  baseDir: string;\n  hasSrcDir: boolean;\n}\n\ninterface PathResolver {\n  resolveProjectConfig(): ProjectConfig;\n  resolveFlagDefsPath(): string;\n  resolveRegistryConfigPath(): string;\n  resolveAbsolutePath(aliasPath: string): string;\n}\n\nexport function createPathResolver(rootDir: string = process.cwd()): PathResolver {\n  function resolveProjectConfig(): ProjectConfig {\n    const componentsJsonPath = path.join(rootDir, \"components.json\");\n    const tsconfigPath = path.join(rootDir, \"tsconfig.json\");\n    \n    let aliases: Record<string, string> = {};\n    let baseDir = rootDir;\n    let hasSrcDir = false;\n\n    // Try to read components.json first\n    if (fs.existsSync(componentsJsonPath)) {\n      try {\n        const componentsConfig = JSON.parse(fs.readFileSync(componentsJsonPath, \"utf8\"));\n        if (componentsConfig.aliases) {\n          aliases = componentsConfig.aliases;\n        }\n      } catch (error) {\n        console.warn(\"Warning: Could not parse components.json, falling back to defaults\");\n      }\n    }\n\n    // If no aliases found, try tsconfig.json\n    if (Object.keys(aliases).length === 0 && fs.existsSync(tsconfigPath)) {\n      try {\n        const tsconfigContent = fs.readFileSync(tsconfigPath, \"utf8\");\n        // Remove comments and parse JSON\n        const cleanContent = tsconfigContent.replace(/\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*$/gm, '');\n        const tsconfig = JSON.parse(cleanContent);\n        \n        if (tsconfig.compilerOptions?.paths) {\n          const paths = tsconfig.compilerOptions.paths;\n          for (const [alias, targets] of Object.entries(paths)) {\n            if (Array.isArray(targets) && targets.length > 0) {\n              // Convert TypeScript path mapping to simple alias\n              const cleanAlias = alias.replace('/*', '');\n              const cleanTarget = (targets[0] as string).replace('/*', '');\n              aliases[cleanAlias] = cleanTarget;\n            }\n          }\n        }\n      } catch (error) {\n        console.warn(\"Warning: Could not parse tsconfig.json, falling back to defaults\");\n      }\n    }\n\n    // Default fallback aliases if none found\n    if (Object.keys(aliases).length === 0) {\n      aliases = {\n        \"@\": \"./src\",\n        \"@/lib\": \"./src/lib\",\n        \"@/components\": \"./src/components\"\n      };\n    }\n\n    // Check if src directory exists\n    hasSrcDir = fs.existsSync(path.join(rootDir, \"src\"));\n\n    return { aliases, baseDir, hasSrcDir };\n  }\n\n  function resolveAbsolutePath(aliasPath: string): string {\n    const config = resolveProjectConfig();\n    \n    // Find matching alias\n    for (const [alias, target] of Object.entries(config.aliases)) {\n      if (aliasPath.startsWith(alias)) {\n        const relativePath = aliasPath.replace(alias, target);\n        return path.resolve(config.baseDir, relativePath);\n      }\n    }\n\n    // If no alias matches, try common patterns\n    if (aliasPath.startsWith(\"@/\")) {\n      const fallbackPath = aliasPath.replace(\"@/\", config.hasSrcDir ? \"src/\" : \"\");\n      return path.resolve(config.baseDir, fallbackPath);\n    }\n\n    // Return as-is if no alias resolution possible\n    return path.resolve(config.baseDir, aliasPath);\n  }\n\n  function resolveFlagDefsPath(): string {\n    return resolveAbsolutePath(\"@/lib/flags/defs\");\n  }\n\n  function resolveRegistryConfigPath(): string {\n    return resolveAbsolutePath(\"@/lib/flags/registry.config.ts\");\n  }\n\n  return {\n    resolveProjectConfig,\n    resolveFlagDefsPath,\n    resolveRegistryConfigPath,\n    resolveAbsolutePath\n  };\n}"
    }
  ]
}