{
  "name": "flags-complete",
  "type": "registry:lib",
  "dependencies": [
    "react@^19.1.0",
    "lucide-react@^0.400.0",
    "class-variance-authority@^0.7.1",
    "clsx@^2.1.1",
    "tailwind-merge@^2.5.4",
    "zod@^3.22.0",
    "tsx@^4.19.2",
    "prompts@^2.4.2",
    "fast-glob@^3.3.2",
    "prettier@^3.4.2"
  ],
  "registryDependencies": [],
  "files": [
    {
      "type": "registry:lib",
      "path": "scripts/check-flags-registry.ts",
      "content": "import fs from \"node:fs\";\nimport path from \"node:path\";\nimport { pathToFileURL } from \"node:url\";\nimport fg from \"fast-glob\";\nimport { createPathResolver } from \"./path-resolver\";\n\nconst ROOT = process.cwd();\nconst pathResolver = createPathResolver(ROOT);\n\n// Use alias-aware path resolution\nconst DEFS_DIR = pathResolver.resolveFlagDefsPath();\nconst REG_FILE = pathResolver.resolveRegistryConfigPath();\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function importTs(p: string): Promise<any> {\n  const url = pathToFileURL(p).href;\n  return await import(url);\n}\n\nasync function main() {\n  // Convert absolute path to relative glob pattern for fast-glob\n  const relativeDefsDir = path.relative(ROOT, DEFS_DIR);\n  const defGlobPattern = path.join(relativeDefsDir, \"**/*.flag.ts\").replace(/\\\\/g, \"/\");\n  const defPaths = await fg(defGlobPattern, { cwd: ROOT });\n  const defs = await Promise.all(\n    defPaths.map(async (rel) => {\n      const abs = path.join(ROOT, rel);\n      const mod = await importTs(abs);\n      const key = mod.key ?? mod.default?.key;\n      if (!key) throw new Error(`Missing export 'key' in ${rel}`);\n      const isPublic = !!(mod.default?.client?.public);\n      return { rel, key: String(key), isPublic };\n    })\n  );\n\n  if (!fs.existsSync(REG_FILE)) throw new Error(\"registry.config.ts not found\");\n  const agg = await importTs(REG_FILE);\n  const regKeys: string[] = Object.keys(agg.registry ?? {});\n  const schemaKeys: string[] = Object.keys(agg.flagSchemas ?? {});\n  const publicKeys: string[] = Array.from(agg.clientFlagKeys ?? []);\n\n  const defKeySet = new Set(defs.map((d) => d.key));\n  const regKeySet = new Set(regKeys);\n  const schemaKeySet = new Set(schemaKeys);\n  const publicKeySet = new Set(publicKeys);\n\n  const missingInRegistry = [...defKeySet].filter((k) => !regKeySet.has(k));\n  const missingInDefs = [...regKeySet].filter((k) => !defKeySet.has(k));\n\n  const schemaNotInRegistry = [...schemaKeySet].filter((k) => !regKeySet.has(k));\n  const registryNotInSchemas = [...regKeySet].filter((k) => !schemaKeySet.has(k));\n\n  const filePublicNotListed = defs.filter((d) => d.isPublic && !publicKeySet.has(d.key)).map((d) => d.key);\n  const listedButNotPublic = publicKeys.filter((k) => {\n    const d = defs.find((x) => x.key === k);\n    return !d?.isPublic;\n  });\n\n  let ok = true;\n  function issue(title: string, items: string[]) {\n    if (!items.length) return;\n    ok = false;\n    console.error(`\\n${title}:`);\n    for (const i of items) console.error(`  - ${i}`);\n  }\n\n  issue(\"Defs present but missing in registry.config\", missingInRegistry);\n  issue(\"Registry keys missing corresponding defs\", missingInDefs);\n  issue(\"flagSchemas keys missing in registry\", schemaNotInRegistry);\n  issue(\"registry keys missing in flagSchemas\", registryNotInSchemas);\n  issue(\"Public flags in files but missing from clientFlagKeys\", filePublicNotListed);\n  issue(\"Keys in clientFlagKeys but flags not marked public in files\", listedButNotPublic);\n\n  if (ok) {\n    console.log(`✔ flags:check OK — ${regKeys.length} registered, ${defs.length} files, ${publicKeys.length} client-exposed`);\n    process.exit(0);\n  } else {\n    process.exit(1);\n  }\n}\n\nmain().catch((e) => {\n  console.error(e);\n  process.exit(1);\n});"
    },
    {
      "type": "registry:lib",
      "path": "scripts/create-flag.ts",
      "content": "import fs from \"node:fs\";\nimport path from \"node:path\";\nimport prompts from \"prompts\";\nimport { createPathResolver } from \"./path-resolver\";\n\nconst ROOT = process.cwd();\nconst pathResolver = createPathResolver(ROOT);\n\n// Use alias-aware path resolution\nconst DEFS_DIR = pathResolver.resolveFlagDefsPath();\nconst REG_FILE = pathResolver.resolveRegistryConfigPath();\n\nfunction snake(s: string) { return s.toLowerCase().replace(/[^a-z0-9]+/g, \"_\").replace(/^_|_$/g, \"\"); }\nfunction kebab(s: string) { return s.toLowerCase().replace(/[^a-z0-9]+/g, \"-\").replace(/^-|-$/g, \"\"); }\n\nasync function main() {\n  const answers = await prompts([\n    { type: \"text\", name: \"key\", message: \"Flag key (kebab-case)\", validate: v => /^[a-z0-9][a-z0-9-]*$/.test(v) ? true : \"kebab-case only\" },\n    { type: \"select\", name: \"kind\", message: \"Value type\", choices: [\n      { title: \"boolean\", value: \"boolean\" },\n      { title: \"string enum\", value: \"enum\" }\n    ]},\n    { type: prev => prev === \"enum\" ? \"list\" : null, name: \"options\", message: \"Enum options (comma-separated)\", separator: \",\" },\n    { type: \"toggle\", name: \"isPublic\", message: \"Expose to client?\", initial: true },\n    { type: prev => prev ? \"text\" : null, name: \"sanitizer\", message: \"Serializer (optional JS expr, e.g. v => !!v)\" },\n    { type: (prev, vals) => vals.kind === \"boolean\" ? \"toggle\" : \"text\", name: \"defaultValue\", message: \"Default value\", initial: true },\n    { type: \"text\", name: \"description\", message: \"Description (optional)\" }\n  ]);\n\n  const key = kebab(answers.key);\n  const base = snake(key);\n  const fileName = `${base}.flag.ts`;\n  const importId = `f_${base}`;\n  const defPath = path.join(DEFS_DIR, fileName);\n  fs.mkdirSync(DEFS_DIR, { recursive: true });\n\n  let schema = \"z.boolean()\";\n  let defVal = String(answers.defaultValue);\n  let optionsBlock = \"\";\n  if (answers.kind === \"enum\") {\n    const opts = (answers.options as string[]).map((s) => s.trim()).filter(Boolean);\n    schema = `z.enum([${opts.map((o) => `\"${o}\"`).join(\", \")}])`;\n    defVal = `\"${opts[0]}\"`;\n    optionsBlock = `\\n  options: [${opts.map((o) => `{ value: \"${o}\" }`).join(\", \")}],`;\n  }\n\n  const clientBlock = answers.isPublic\n    ? answers.sanitizer\n      ? `\\n  client: { public: true, serialize: ${answers.sanitizer} },`\n      : `\\n  client: { public: true },`\n    : `\\n  client: { public: false },`;\n\n  const contents = `import { z } from \"zod\";\nimport { defineFlag } from \"../kit\";\n\nexport const key = \"${key}\" as const;\nexport const schema = ${schema};\n\nexport default defineFlag({\n  key,\n  schema,\n  description: ${JSON.stringify(answers.description || \"\")},\n  defaultValue: ${defVal},${optionsBlock}${clientBlock}\n});\n`;\n\n  // Write flag file (skip if exists)\n  if (!fs.existsSync(defPath)) {\n    fs.writeFileSync(defPath, contents, \"utf8\");\n    console.log(\"✔ created\", path.relative(ROOT, defPath));\n  } else {\n    console.log(\"ℹ exists\", path.relative(ROOT, defPath), \"— not overwriting\");\n  }\n\n  // Update registry.config.ts\n  let cfg = fs.readFileSync(REG_FILE, \"utf8\");\n  const importLine = `import * as ${importId} from \"./defs/${base}.flag\";`;\n  if (!cfg.includes(importLine)) {\n    cfg = inject(cfg, /\\/\\/ @fargo-flags:imports\\n/, importLine + \"\\n\");\n  }\n\n  const schemaEntry = `  \"${key}\": ${importId}.schema,`;\n  if (!cfg.includes(schemaEntry)) {\n    cfg = inject(cfg, /\\/\\/ @fargo-flags:schemas\\n/, schemaEntry + \"\\n\");\n  }\n\n  const regEntry = `  \"${key}\": ${importId}.default,`;\n  if (!cfg.includes(regEntry)) {\n    cfg = inject(cfg, /\\/\\/ @fargo-flags:registry\\n/, regEntry + \"\\n\");\n  }\n\n  if (answers.isPublic) {\n    const pubEntry = `  \"${key}\",`;\n    if (!cfg.includes(pubEntry)) {\n      cfg = inject(cfg, /\\/\\/ @fargo-flags:public\\n/, pubEntry + \"\\n\");\n    }\n  }\n\n  fs.writeFileSync(REG_FILE, cfg, \"utf8\");\n  console.log(\"✔ updated\", path.relative(ROOT, REG_FILE));\n\n  // Auto-format with Prettier if available\n  await formatFiles([defPath, REG_FILE]);\n}\n\nfunction inject(src: string, anchor: RegExp, text: string) {\n  const m = src.match(anchor);\n  if (!m) throw new Error(\"Anchor not found in registry.config.ts\");\n  const insertAt = (m.index ?? 0) + m[0].length;\n  return src.slice(0, insertAt) + text + src.slice(insertAt);\n}\n\nasync function formatFiles(files: string[]) {\n  try {\n    const prettier = await import(\"prettier\");\n    for (const file of files) {\n      const src = fs.readFileSync(file, \"utf8\");\n      const cfg = await prettier.resolveConfig(file).catch(() => null);\n      const formatted = await prettier.format(src, { ...(cfg ?? {}), filepath: file });\n      fs.writeFileSync(file, formatted, \"utf8\");\n      console.log(\"✔ formatted\", path.relative(ROOT, file));\n    }\n  } catch {\n    console.warn(\"(prettier not installed — skipping format)\");\n  }\n}\n\nmain().catch((e) => { console.error(e); process.exit(1); });"
    },
    {
      "type": "registry:lib",
      "path": "scripts/path-resolver.ts",
      "content": "import fs from \"node:fs\";\nimport path from \"node:path\";\n\ninterface ProjectConfig {\n  aliases: Record<string, string>;\n  baseDir: string;\n  hasSrcDir: boolean;\n}\n\ninterface PathResolver {\n  resolveProjectConfig(): ProjectConfig;\n  resolveFlagDefsPath(): string;\n  resolveRegistryConfigPath(): string;\n  resolveAbsolutePath(aliasPath: string): string;\n}\n\nexport function createPathResolver(rootDir: string = process.cwd()): PathResolver {\n  function resolveProjectConfig(): ProjectConfig {\n    const componentsJsonPath = path.join(rootDir, \"components.json\");\n    const tsconfigPath = path.join(rootDir, \"tsconfig.json\");\n    \n    let aliases: Record<string, string> = {};\n    let baseDir = rootDir;\n    let hasSrcDir = false;\n\n    // Try to read components.json first\n    if (fs.existsSync(componentsJsonPath)) {\n      try {\n        const componentsConfig = JSON.parse(fs.readFileSync(componentsJsonPath, \"utf8\"));\n        if (componentsConfig.aliases) {\n          aliases = componentsConfig.aliases;\n        }\n      } catch (error) {\n        console.warn(\"Warning: Could not parse components.json, falling back to defaults\");\n      }\n    }\n\n    // If no aliases found, try tsconfig.json\n    if (Object.keys(aliases).length === 0 && fs.existsSync(tsconfigPath)) {\n      try {\n        const tsconfigContent = fs.readFileSync(tsconfigPath, \"utf8\");\n        // Remove comments and parse JSON\n        const cleanContent = tsconfigContent.replace(/\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*$/gm, '');\n        const tsconfig = JSON.parse(cleanContent);\n        \n        if (tsconfig.compilerOptions?.paths) {\n          const paths = tsconfig.compilerOptions.paths;\n          for (const [alias, targets] of Object.entries(paths)) {\n            if (Array.isArray(targets) && targets.length > 0) {\n              // Convert TypeScript path mapping to simple alias\n              const cleanAlias = alias.replace('/*', '');\n              const cleanTarget = (targets[0] as string).replace('/*', '');\n              aliases[cleanAlias] = cleanTarget;\n            }\n          }\n        }\n      } catch (error) {\n        console.warn(\"Warning: Could not parse tsconfig.json, falling back to defaults\");\n      }\n    }\n\n    // Default fallback aliases if none found\n    if (Object.keys(aliases).length === 0) {\n      aliases = {\n        \"@\": \"./src\",\n        \"@/lib\": \"./src/lib\",\n        \"@/components\": \"./src/components\"\n      };\n    }\n\n    // Check if src directory exists\n    hasSrcDir = fs.existsSync(path.join(rootDir, \"src\"));\n\n    return { aliases, baseDir, hasSrcDir };\n  }\n\n  function resolveAbsolutePath(aliasPath: string): string {\n    const config = resolveProjectConfig();\n    \n    // Find matching alias\n    for (const [alias, target] of Object.entries(config.aliases)) {\n      if (aliasPath.startsWith(alias)) {\n        const relativePath = aliasPath.replace(alias, target);\n        return path.resolve(config.baseDir, relativePath);\n      }\n    }\n\n    // If no alias matches, try common patterns\n    if (aliasPath.startsWith(\"@/\")) {\n      const fallbackPath = aliasPath.replace(\"@/\", config.hasSrcDir ? \"src/\" : \"\");\n      return path.resolve(config.baseDir, fallbackPath);\n    }\n\n    // Return as-is if no alias resolution possible\n    return path.resolve(config.baseDir, aliasPath);\n  }\n\n  function resolveFlagDefsPath(): string {\n    return resolveAbsolutePath(\"@/lib/flags/defs\");\n  }\n\n  function resolveRegistryConfigPath(): string {\n    return resolveAbsolutePath(\"@/lib/flags/registry.config.ts\");\n  }\n\n  return {\n    resolveProjectConfig,\n    resolveFlagDefsPath,\n    resolveRegistryConfigPath,\n    resolveAbsolutePath\n  };\n}"
    },
    {
      "type": "registry:component",
      "path": "components/flags/flag.tsx",
      "content": "\"use client\";\nimport { ReactNode } from \"react\";\nimport { useFlag } from \"./flags-provider\";\nimport type { ClientFlags } from \"@/lib/flags/runtime\";\n\ntype Props<K extends keyof ClientFlags> = {\n  when: K;               // flag key\n  is?: ClientFlags[K];   // render when value === is\n  not?: ClientFlags[K];  // render when value !== not\n  fallback?: ReactNode;\n  children: ReactNode;\n};\n\nexport function Flag<K extends keyof ClientFlags>({\n  when,\n  is,\n  not,\n  fallback = null,\n  children,\n}: Props<K>) {\n  const value = useFlag(when);\n  const pass =\n    typeof is !== \"undefined\"\n      ? value === is\n      : typeof not !== \"undefined\"\n      ? value !== not\n      : Boolean(value);\n  return pass ? <>{children}</> : <>{fallback}</>;\n}"
    },
    {
      "type": "registry:component",
      "path": "components/flags/flags-provider.tsx",
      "content": "\"use client\";\nimport { createContext, useContext } from \"react\";\nimport type { ClientFlags } from \"@/lib/flags/runtime\";\n\nconst FlagsContext = createContext<ClientFlags | null>(null);\n\nexport function FlagsProvider({\n  flags,\n  children,\n}: {\n  flags: ClientFlags;\n  children: React.ReactNode;\n}) {\n  return <FlagsContext.Provider value={flags}>{children}</FlagsContext.Provider>;\n}\n\nexport function useFlags(): ClientFlags {\n  const ctx = useContext(FlagsContext);\n  if (!ctx) throw new Error(\"useFlags must be used within <FlagsProvider />\");\n  return ctx;\n}\n\nexport function useFlag<K extends keyof ClientFlags>(key: K): ClientFlags[K] {\n  return useFlags()[key];\n}"
    },
    {
      "type": "registry:component",
      "path": "components/flags/flags-test-provider.tsx",
      "content": "\"use client\";\nimport { PropsWithChildren, useMemo } from \"react\";\nimport { FlagsProvider } from \"./flags-provider\";\nimport { defaultFlags, pickClientFlags } from \"@/lib/flags/runtime\";\n\nexport type PartialClientFlags = Partial<ReturnType<typeof pickClientFlags>>;\n\nexport function FlagsTestProvider({\n  overrides = {},\n  children,\n}: PropsWithChildren<{ overrides?: PartialClientFlags }>) {\n  const clientDefault = pickClientFlags(defaultFlags);\n  const flags = useMemo(() => ({ ...clientDefault, ...overrides }), [clientDefault, overrides]);\n  return <FlagsProvider flags={flags}>{children}</FlagsProvider>;\n}"
    },
    {
      "type": "registry:lib",
      "path": "lib/flags/kit.ts",
      "content": "import { z } from \"zod\";\n\nexport type FlagContext = {\n  getUser?: () => Promise<{ id: string; plan?: string } | null>;\n  getWorkspace?: () => Promise<{ id: string; plan?: string } | null>;\n};\n\nexport type ClientExposure<T = unknown> =\n  | { public: true; serialize?: (value: T) => unknown } // exposed to client\n  | { public: false }; // server-only\n\nexport type FlagDefinition<S extends z.ZodTypeAny> = {\n  key: string;\n  schema: S;\n  description?: string;\n  defaultValue: z.infer<S>;\n  options?: { value: z.infer<S>; label?: string }[];\n  client?: ClientExposure<z.infer<S>>; // NEXT_PUBLIC-style control\n  decide?: (ctx: FlagContext) => z.infer<S> | Promise<z.infer<S>>; // server-side only\n};\n\nexport function defineFlag<S extends z.ZodTypeAny>(def: FlagDefinition<S>) {\n  return def;\n}"
    },
    {
      "type": "registry:lib",
      "path": "lib/flags/registry.config.ts",
      "content": "import { z } from \"zod\";\nimport type { FlagDefinition } from \"./kit\";\n\n/**\n * Managed regions — the wizard inserts new imports and entries\n * between these tags. Manual edits are fine too.\n */\n\n// @fargo-flags:imports\n// @fargo-flags:imports:end\n\nexport const flagSchemas = {\n  // @fargo-flags:schemas\n  // @fargo-flags:schemas:end\n} as const;\n\nexport const registry = {\n  // @fargo-flags:registry\n  // @fargo-flags:registry:end\n} as const satisfies Record<\n  keyof typeof flagSchemas,\n  FlagDefinition<z.ZodTypeAny>\n>;\n\n/** Keys safe to send to the client (NEXT_PUBLIC-style). */\nexport const clientFlagKeys = [\n  // @fargo-flags:public\n  // @fargo-flags:public:end\n] as const;\n\nexport type SchemaMap = typeof flagSchemas;\nexport type FlagKey = keyof SchemaMap;"
    },
    {
      "type": "registry:lib",
      "path": "lib/flags/runtime.ts",
      "content": "import { z } from \"zod\";\nimport {\n  flagSchemas,\n  registry,\n  clientFlagKeys,\n  type SchemaMap,\n} from \"./registry.config\";\nimport type { FlagContext } from \"./kit\";\n\nexport type Flags = { [K in keyof SchemaMap]: z.infer<SchemaMap[K]> };\nexport type FlagKey = keyof Flags;\n\nexport type ClientSchemaMap = Pick<SchemaMap, (typeof clientFlagKeys)[number]>;\nexport type ClientFlags = {\n  [K in keyof ClientSchemaMap]: z.infer<ClientSchemaMap[K]>;\n};\n\nexport const defaultFlags = Object.fromEntries(\n  Object.entries(registry).map(([key, def]) => [key, def.defaultValue])\n) as Flags;\n\n/** Resolve all flags on the server, validate against schemas. */\nexport async function resolveAllFlags(ctx?: FlagContext): Promise<Flags> {\n  const keys = Object.keys(registry) as (keyof SchemaMap)[];\n\n  // Handle empty registry case\n  if (keys.length === 0) {\n    return {} as Flags;\n  }\n\n  const entries = await Promise.all(\n    keys.map(async (key) => {\n      const def = registry[key];\n      const raw = await Promise.resolve(\n        def.decide?.(ctx!) ?? def.defaultValue\n      );\n      const value = flagSchemas[key].parse(raw);\n      return [key, value] as const;\n    })\n  );\n  return Object.fromEntries(entries) as Flags;\n}\n\n/** Create the client-safe subset (applies optional per-flag 'serialize'). */\nexport function pickClientFlags(flags: Flags): ClientFlags {\n  const out: Record<string, unknown> = {};\n  for (const key of clientFlagKeys) {\n    out[key as string] = flags[key];\n  }\n  return out as ClientFlags;\n}\n"
    },
    {
      "type": "registry:lib",
      "path": "lib/utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n"
    }
  ]
}